<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>My New Post</title>
    <url>/2022/12/24/My-New-Post/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python_argparse</title>
    <url>/2022/12/26/python-argparse/</url>
    <content><![CDATA[<p>本篇文章我们介绍一下Python的argparse模块</p>
<span id="more"></span>

<h2 id="背景与意义"><a href="#背景与意义" class="headerlink" title="背景与意义"></a>背景与意义</h2><p>首先，我们为什么要使用这个模块</p>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Argparse</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows11 WSL2搭建Gadgetron环境(一)：Gadgetron介绍</title>
    <url>/2022/12/24/wsl2_gadgetron1/</url>
    <content><![CDATA[<p>借助Windows11 WSL2功能，搭建Gadgetron MRI重建平台环境。</p>
<span id="more"></span>

<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>还没有内容</p>
<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在使用Gadgetron之前，我们先简单了解一下什么是Gadgetron，以及为什么要使用Gadgetron。</p>
<h2 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_chan_group</span>(<span class="params">chans, exclude=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Group iEEG channel</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    chans: list</span></span><br><span class="line"><span class="string">        channels&#x27; name</span></span><br><span class="line"><span class="string">    exclude: list</span></span><br><span class="line"><span class="string">        channels need to be excluded</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    chan_group: dict  group: channels</span></span><br><span class="line"><span class="string">        channels belong to each group</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(exclude, <span class="built_in">list</span>):</span><br><span class="line">        [chans.pop(chans.index(ch)) <span class="keyword">for</span> ch <span class="keyword">in</span> exclude]</span><br><span class="line"></span><br><span class="line">    group_chs = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> chans:</span><br><span class="line">        <span class="keyword">match</span> = <span class="string">r&quot;([a-zA-Z]+&#x27;)&quot;</span> <span class="keyword">if</span> <span class="string">&quot;&#x27;&quot;</span> <span class="keyword">in</span> ch <span class="keyword">else</span> <span class="string">r&quot;([a-zA-Z]+)&quot;</span></span><br><span class="line">        group = re.<span class="keyword">match</span>(<span class="keyword">match</span>, ch, re.I).group()</span><br><span class="line">        <span class="keyword">if</span> group <span class="keyword">not</span> <span class="keyword">in</span> group_chs:</span><br><span class="line">            group_chs[group] = [ch]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            group_chs[group].append(ch)</span><br><span class="line">    <span class="keyword">return</span> group_chs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_ch_pos</span>(<span class="params">tip, tail, ch_num, dist=<span class="number">3.5</span>, extra_interval=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Calculate channels&#x27; position in the same shaft</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    tip: list | np.array shape (3, 1)</span></span><br><span class="line"><span class="string">        the first contact&#x27;s coordinates, should be in Surface RAS</span></span><br><span class="line"><span class="string">    tail: list | np.array shape (3, 1)</span></span><br><span class="line"><span class="string">        the tail&#x27;s coordinates</span></span><br><span class="line"><span class="string">    ch_num: int</span></span><br><span class="line"><span class="string">        the number of contacts in this shaft, should be in Surface RAS</span></span><br><span class="line"><span class="string">    dist: int | float</span></span><br><span class="line"><span class="string">        the distance between the center of mass of contacts</span></span><br><span class="line"><span class="string">    extra_interval: int | float</span></span><br><span class="line"><span class="string">        not uniformly-spaced at the middle should be 12</span></span><br><span class="line"><span class="string">        specify for 16 contacts</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    ch_pos: np.array shape (n_contacts, 3)</span></span><br><span class="line"><span class="string">        The coordinates of the channels in this shaft</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(tip) == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">len</span>(tail) == <span class="number">3</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(ch_num, <span class="built_in">int</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(dist, <span class="built_in">int</span>) <span class="keyword">or</span> <span class="built_in">isinstance</span>(dist, <span class="built_in">float</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tip, np.ndarray):</span><br><span class="line">        tip = np.asarray(tip)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tail, np.ndarray):</span><br><span class="line">        tail = np.asarray(tail)</span><br><span class="line">    xyz_diff = tail.astype(np.float64) - tip.astype(np.float64)</span><br><span class="line">    line_len = np.sqrt(xyz_diff[<span class="number">0</span>] ** <span class="number">2</span> + xyz_diff[<span class="number">1</span>] ** <span class="number">2</span> + xyz_diff[<span class="number">2</span>] ** <span class="number">2</span>)</span><br><span class="line">    ch_pos = np.zeros((ch_num, <span class="number">3</span>))</span><br><span class="line">    ch_pos[<span class="number">0</span>, :] = tip</span><br><span class="line">    xyz_unit = dist * xyz_diff / line_len</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, ch_num):</span><br><span class="line">        ch_pos[i, :] = tip + xyz_unit * i</span><br><span class="line">    <span class="keyword">if</span> extra_interval <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">assert</span> ch_num == <span class="number">16</span></span><br><span class="line"></span><br><span class="line">        extra_dist = extra_interval - dist</span><br><span class="line">        <span class="keyword">assert</span> extra_dist &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        xyz_extra = extra_dist * xyz_diff / line_len</span><br><span class="line">        ch_pos[ch_num//<span class="number">2</span>:, :] += xyz_extra</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">round</span>(ch_pos, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reorder_chs</span>(<span class="params">chs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Reorder iEEG channels&#x27; name</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    chs : list of str</span></span><br><span class="line"><span class="string">        The name of channels</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    sorted_chs : list of str</span></span><br><span class="line"><span class="string">        The right sorted name of channels</span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    The code is from</span></span><br><span class="line"><span class="string">    https://stackoverflow.com/questions/71410219/reorder-a-list-with-elements-in-the-format-like-letternumber</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Because of the file exporting software of iEEG, the channels&#x27; names are always in the</span></span><br><span class="line"><span class="string">    wrong order. The expected order is like</span></span><br><span class="line"><span class="string">    [&#x27;A1&#x27;, &#x27;A2&#x27;, &#x27;A3&#x27;, &#x27;A11&#x27;, &#x27;A12&#x27;, &#x27;B1&#x27;, &#x27;B12&#x27;, &#x27;EC1&#x27;, &#x27;EC21&#x27;]</span></span><br><span class="line"><span class="string">    The code here considered both different length of channels&#x27; group and number using RegEx</span></span><br><span class="line"><span class="string">    The idea of this code is</span></span><br><span class="line"><span class="string">    1. separate the group and num</span></span><br><span class="line"><span class="string">    2. save num to the corresponding group</span></span><br><span class="line"><span class="string">    3. sort the group</span></span><br><span class="line"><span class="string">    4. sort the num in each group</span></span><br><span class="line"><span class="string">    5. merge the group+num</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    unsorted_chs_dict = &#123;&#125;</span><br><span class="line">    post_node = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> ch <span class="keyword">in</span> chs:</span><br><span class="line">        <span class="comment"># Get the letter part and the number part</span></span><br><span class="line">        <span class="comment"># The letter is the group of this contact</span></span><br><span class="line">        <span class="comment"># and the number is the serial number of this contact</span></span><br><span class="line">        quote = <span class="string">&quot;&#x27;&quot;</span> <span class="keyword">in</span> ch</span><br><span class="line">        <span class="keyword">if</span> quote:</span><br><span class="line">            <span class="comment"># In this case, the contact&#x27;s name is like A&#x27;1 or A&#x27;1-A&#x27;2</span></span><br><span class="line">            <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&quot;([a-zA-Z]+)(&#x27;)([0-9]+)&quot;</span>, ch, re.I)</span><br><span class="line">            ch_group = <span class="keyword">match</span>.groups()[<span class="number">0</span>] + <span class="keyword">match</span>.groups()[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># have to int the num so it would be sorted by the rule of int</span></span><br><span class="line">            <span class="comment"># not the rule of str</span></span><br><span class="line">            ch_num = <span class="built_in">int</span>(<span class="keyword">match</span>.groups()[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># In this case, the contact&#x27;s name is like A1 or A1-A2</span></span><br><span class="line">            <span class="keyword">match</span> = re.<span class="keyword">match</span>(<span class="string">r&quot;([a-zA-Z]+)([0-9]+)&quot;</span>, ch, re.I)</span><br><span class="line">            ch_group = <span class="keyword">match</span>.groups()[<span class="number">0</span>]</span><br><span class="line">            ch_num = <span class="built_in">int</span>(<span class="keyword">match</span>.groups()[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> ch_group <span class="keyword">in</span> unsorted_chs_dict:</span><br><span class="line">            unsorted_chs_dict[ch_group].append(ch_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            unsorted_chs_dict[ch_group] = [ch_num]</span><br><span class="line">        ch_len = <span class="built_in">len</span>(ch_group) + <span class="built_in">len</span>(<span class="built_in">str</span>(ch_num))</span><br><span class="line">        <span class="keyword">if</span> ch_len &lt; <span class="built_in">len</span>(ch):</span><br><span class="line">            <span class="comment"># if bipolar, restore its post channel&#x27;s name with -</span></span><br><span class="line">            post_node[<span class="string">f&#x27;<span class="subst">&#123;ch_group&#125;</span><span class="subst">&#123;ch_num&#125;</span>&#x27;</span>] = ch[ch_len:]</span><br><span class="line">    <span class="comment"># sort the channels&#x27; group, aka the keys of dict</span></span><br><span class="line">    ch_group_sorted_dict = OrderedDict(<span class="built_in">sorted</span>(unsorted_chs_dict.items()))</span><br><span class="line"></span><br><span class="line">    sorted_chs = []</span><br><span class="line">    <span class="keyword">for</span> group <span class="keyword">in</span> ch_group_sorted_dict:</span><br><span class="line">        <span class="keyword">for</span> ch_num <span class="keyword">in</span> <span class="built_in">sorted</span>(ch_group_sorted_dict[group]):</span><br><span class="line">            ch_name = <span class="string">f&#x27;<span class="subst">&#123;group&#125;</span><span class="subst">&#123;ch_num&#125;</span>&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> ch_name <span class="keyword">in</span> post_node:</span><br><span class="line">                ch_name += post_node[ch_name]</span><br><span class="line">            sorted_chs.append(ch_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sorted_chs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> os.path <span class="keyword">as</span> op</span><br><span class="line">    <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">    help_text = <span class="string">f&quot;Adjust special contacts&#x27; location&quot;</span></span><br><span class="line">    parser = argparse.ArgumentParser(description=help_text)</span><br><span class="line"></span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-i&#x27;</span>, <span class="string">&#x27;--input_path&#x27;</span>, dest=<span class="string">&#x27;fpath&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;coordinates file path&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-g&#x27;</span>, <span class="string">&#x27;--group&#x27;</span>, dest=<span class="string">&#x27;group&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">list</span>, default=[],</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;group of contacts to revise&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-n&#x27;</span>, <span class="string">&#x27;--ch_num&#x27;</span>, dest=<span class="string">&#x27;ch_num&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">16</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;number of contacts&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-d&#x27;</span>, <span class="string">&#x27;--dist&#x27;</span>, dest=<span class="string">&#x27;dist&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">3.5</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;distance of contacts&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-e&#x27;</span>, <span class="string">&#x27;--extra_interval&#x27;</span>, dest=<span class="string">&#x27;extra_interval&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>, default=<span class="number">12</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;extra interval of contacts&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-s&#x27;</span>, <span class="string">&#x27;--save_path&#x27;</span>, dest=<span class="string">&#x27;save_path&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, default=<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&#x27;revised coordinates save path&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    fpath = args.fpath</span><br><span class="line">    group = args.group</span><br><span class="line">    ch_num = args.ch_num</span><br><span class="line">    dist = args.dist</span><br><span class="line">    extra_interval = args.extra_interval</span><br><span class="line">    save_path = args.save_path</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> op.exists(fpath):</span><br><span class="line">        <span class="keyword">raise</span> FileNotFoundError(<span class="string">f&#x27;No such file or directory: <span class="subst">&#123;fpath&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> save_path.endswith(<span class="string">&#x27;.txt&#x27;</span>):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;Wrong save path format \n&#x27;</span></span><br><span class="line">                         <span class="string">f&#x27;should be like *.txt&#x27;</span>)</span><br><span class="line">    coords = pd.read_table(fpath)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Loading coordinates from <span class="subst">&#123;fpath&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Revising group <span class="subst">&#123;group&#125;</span> using distance <span class="subst">&#123;dist&#125;</span> with extra interval <span class="subst">&#123;extra_interval&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    ch_names = coords[<span class="string">&#x27;Channel&#x27;</span>].to_list()</span><br><span class="line">    xyz = coords[[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]].to_numpy()</span><br><span class="line">    ch_pos = <span class="built_in">dict</span>(<span class="built_in">zip</span>(ch_names, xyz))</span><br><span class="line">    group_chs = get_chan_group(ch_names)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(group):</span><br><span class="line">        <span class="keyword">for</span> g <span class="keyword">in</span> group:</span><br><span class="line">            <span class="keyword">if</span> g <span class="keyword">not</span> <span class="keyword">in</span> group_chs:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&#x27;No group <span class="subst">&#123;g&#125;</span> in this file&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                g_chs = group_chs[g]</span><br><span class="line">                tip_name = g_chs[<span class="number">0</span>]</span><br><span class="line">                tail_name = g_chs[-<span class="number">1</span>]</span><br><span class="line">                tip = ch_pos[tip_name]</span><br><span class="line">                tail = ch_pos[tail_name]</span><br><span class="line">                g_ch_pos = calc_ch_pos(tip, tail, ch_num, dist, extra_interval)</span><br><span class="line">                <span class="keyword">for</span> index, ch <span class="keyword">in</span> <span class="built_in">enumerate</span>(g_chs):</span><br><span class="line">                    ch_index = ch_names.index(ch)</span><br><span class="line">                    coords.loc[ch_index, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>]] = g_ch_pos[index]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># from matplotlib import pyplot as plt</span></span><br><span class="line">                <span class="comment">#</span></span><br><span class="line">                <span class="comment"># fig = plt.figure()</span></span><br><span class="line">                <span class="comment"># ax = fig.add_subplot(projection=&#x27;3d&#x27;)</span></span><br><span class="line">                <span class="comment"># ax.scatter(g_ch_pos[:, 0], g_ch_pos[:, 1], g_ch_pos[:, 2])</span></span><br><span class="line">                <span class="comment"># plt.show(block=True)</span></span><br><span class="line">        coords.to_csv(save_path, sep=<span class="string">&#x27;\t&#x27;</span>, index=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Gadgetron</category>
      </categories>
      <tags>
        <tag>MRI</tag>
        <tag>Gadgetron</tag>
        <tag>Reconstruction</tag>
      </tags>
  </entry>
</search>
